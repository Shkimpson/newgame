diff --git a/README_SEED.md b/README_SEED.md
new file mode 100644
index 0000000..1111111
--- /dev/null
+++ b/README_SEED.md
@@ -0,0 +1,35 @@
+# Weavebound — Seed 02 (HUD + Pixel scale)
+
+This patch adds:
+- **PixelScale.cs** — runtime letterbox/pillarbox to a reference resolution (default 320×180).
+- **BattleHUDLayout.cs** — Undertale-like rectangles (Message bottom, Menu above, SOUL box mid).
+- **BattleHUDImmediate.cs** — OnGUI prototype that draws the HUD frames using the layout.
+  (No TextMeshPro dependency; we’ll swap to TMP in a later PR.)
+
+## Hook-up steps
+
+1) **Boot scene**: make sure the `Game` bootstrap is present (from Seed 01).
+2) **Battle scene**:
+   - Create an empty GameObject `Battle` and add `Weavebound.Battle.BattleController` (from Seed 01).
+   - Add `Weavebound.UI.PixelScale` to the **Main Camera**. Set Reference Width **320**, Height **180**.
+   - Add `Weavebound.Battle.BattleHUDLayout` to any GameObject (e.g., `BattleHUD`).
+   - Add `Weavebound.Battle.BattleHUDImmediate` to the same object. Assign its `layout` field.
+   - Press Play. You should see three framed regions:
+       - bottom **Message** box,
+       - a slim **Menu** bar above it,
+       - centered **SOUL** box in the middle.
+   - Press **Enter/Z/Space** to cycle phases (Menu → Fight → Enemy Turn → Message).
+
+3) **Next PR (seed 03)** will replace OnGUI with **TextMeshPro** UI and add **Yarn Spinner** wiring.
+
+## Design goals enforced
+- Message is always bottom-most.
+- Menu is slim and above message.
+- SOUL box is centered mid-screen, ~70–80% of content width, ~35% of height.
+- The layout adapts safely from 720p → 4K while preserving pixel scale via letterboxing.
diff --git a/Assets/Scripts/UI/PixelScale.cs b/Assets/Scripts/UI/PixelScale.cs
new file mode 100644
index 0000000..1111111
--- /dev/null
+++ b/Assets/Scripts/UI/PixelScale.cs
@@ -0,0 +1,38 @@
+using UnityEngine;
+
+namespace Weavebound.UI {
+  [RequireComponent(typeof(Camera))]
+  public class PixelScale : MonoBehaviour {
+    public int referenceWidth = 320;
+    public int referenceHeight = 180;
+    public bool integerScale = true;
+
+    Camera cam;
+    void Awake(){ cam = GetComponent<Camera>(); cam.orthographic = true; }
+
+    void OnPreCull(){
+      // Compute target scale that fits inside the current window
+      float scaleX = (float)Screen.width / referenceWidth;
+      float scaleY = (float)Screen.height / referenceHeight;
+      float scale = Mathf.Min(scaleX, scaleY);
+      if (integerScale) scale = Mathf.Max(1f, Mathf.Floor(scale));
+
+      // Compute viewport rect to letterbox/pillarbox
+      float vw = (referenceWidth * scale) / Screen.width;
+      float vh = (referenceHeight * scale) / Screen.height;
+      float vx = (1f - vw) * 0.5f;
+      float vy = (1f - vh) * 0.5f;
+      cam.rect = new Rect(vx, vy, vw, vh);
+    }
+  }
+}
diff --git a/Assets/Scripts/Battle/BattleHUDLayout.cs b/Assets/Scripts/Battle/BattleHUDLayout.cs
new file mode 100644
index 0000000..1111111
--- /dev/null
+++ b/Assets/Scripts/Battle/BattleHUDLayout.cs
@@ -0,0 +1,56 @@
+using UnityEngine;
+
+namespace Weavebound.Battle {
+  /// Computes Undertale-like HUD rectangles from the current screen and camera viewport.
+  public class BattleHUDLayout : MonoBehaviour {
+    [Header("Fractions (relative to viewport)")]
+    [Range(0.1f,0.5f)] public float messageHeightFrac = 0.16f;
+    [Range(0.08f,0.3f)] public float menuHeightFrac = 0.14f;
+    [Range(0.4f,0.9f)] public float soulWidthFrac = 0.78f;
+    [Range(0.2f,0.6f)] public float soulHeightFrac = 0.36f;
+    [Range(0f,0.1f)] public float marginFrac = 0.03f;
+    public Rect RectEnemy { get; private set; }
+    public Rect RectMsg   { get; private set; }
+    public Rect RectMenu  { get; private set; }
+    public Rect RectSoul  { get; private set; }
+
+    void LateUpdate(){
+      // Use camera rect to handle letterboxing
+      var cam = Camera.main;
+      Rect vp = cam ? cam.rect : new Rect(0,0,1,1);
+      float W = Screen.width  * vp.width;
+      float H = Screen.height * vp.height;
+      float ox = Screen.width  * vp.x;
+      float oy = Screen.height * vp.y;
+      float m  = marginFrac * Mathf.Min(W,H);
+
+      float msgH  = Mathf.Clamp(messageHeightFrac * H, 44f, 96f);
+      float menuH = Mathf.Clamp(menuHeightFrac    * H, 40f, 84f);
+      float soulW = Mathf.Clamp(soulWidthFrac     * (W - 2*m), 240f, W - 2*m);
+      float soulH = Mathf.Clamp(soulHeightFrac    * (H - msgH - menuH - 3*m), 90f, H*0.6f);
+
+      RectMsg  = new Rect(ox + m, oy + H - msgH - m, W - 2*m, msgH);
+      RectMenu = new Rect(ox + m, RectMsg.yMin - menuH - m*0.5f, W - 2*m, menuH);
+      RectSoul = new Rect(ox + (W - soulW)/2f, RectMenu.yMin - soulH - m*0.5f, soulW, soulH);
+
+      // Enemy band: top area
+      float enemyH = Mathf.Clamp(0.22f * H, 56f, 180f);
+      RectEnemy = new Rect(ox + m, oy + m*0.5f, W - 2*m, enemyH);
+    }
+
+    void OnDrawGizmos(){
+      // Debug bounds in editor/play
+      Gizmos.color = Color.white; DrawRect(RectEnemy);
+      Gizmos.color = Color.yellow; DrawRect(RectSoul);
+      Gizmos.color = Color.gray; DrawRect(RectMenu);
+      Gizmos.color = Color.cyan; DrawRect(RectMsg);
+    }
+    void DrawRect(Rect r){
+      Vector3 a=new Vector3(r.xMin,r.yMin,0), b=new Vector3(r.xMax,r.yMin,0), c=new Vector3(r.xMax,r.yMax,0), d=new Vector3(r.xMin,r.yMax,0);
+      Gizmos.DrawLine(a,b); Gizmos.DrawLine(b,c); Gizmos.DrawLine(c,d); Gizmos.DrawLine(d,a);
+    }
+  }
+}
diff --git a/Assets/Scripts/Battle/BattleHUDImmediate.cs b/Assets/Scripts/Battle/BattleHUDImmediate.cs
new file mode 100644
index 0000000..1111111
--- /dev/null
+++ b/Assets/Scripts/Battle/BattleHUDImmediate.cs
@@ -0,0 +1,44 @@
+using UnityEngine;
+
+namespace Weavebound.Battle {
+  /// Immediate-mode prototype HUD to visualize layout without TMP/UI.
+  public class BattleHUDImmediate : MonoBehaviour {
+    public BattleHUDLayout layout;
+    public string message = "The air hums.";
+    public string[] menu = new[]{"FIGHT","ACT","ITEM","MERCY"};
+    public int menuIndex = 0;
+
+    void OnGUI(){
+      if (layout==null) return;
+      var c = GUI.color;
+      // Enemy band
+      GUI.color = Color.white; GUI.Box(Px(layout.RectEnemy), GUIContent.none);
+      GUI.Label(new Rect(layout.RectEnemy.x+8, layout.RectEnemy.y+4, 240, 24), "Sprout");
+      // Soul box
+      GUI.color = Color.white; GUI.Box(Px(layout.RectSoul), GUIContent.none);
+      // Menu
+      GUI.color = Color.white; GUI.Box(Px(layout.RectMenu), GUIContent.none);
+      float step = layout.RectMenu.width / Mathf.Max(1, menu.Length);
+      for(int i=0;i<menu.Length;i++){
+        var r = new Rect(layout.RectMenu.x + i*step + 12, layout.RectMenu.y + layout.RectMenu.height*0.30f, 100, 22);
+        GUI.color = (i==menuIndex)? Color.yellow : Color.white;
+        GUI.Label(r, menu[i]);
+      }
+      // Message (bottom)
+      GUI.color = Color.white; GUI.Box(Px(layout.RectMsg), GUIContent.none);
+      var msgR = new Rect(layout.RectMsg.x+8, layout.RectMsg.y+6, layout.RectMsg.width-16, layout.RectMsg.height-12);
+      GUI.Label(msgR, message);
+      GUI.color = c;
+    }
+
+    Rect Px(Rect r){ return r; } // OnGUI already uses pixels
+  }
+}
diff --git a/Docs/BattleHUD.md b/Docs/BattleHUD.md
new file mode 100644
index 0000000..1111111
--- /dev/null
+++ b/Docs/BattleHUD.md
@@ -0,0 +1,18 @@
+# Battle HUD composition
+
+Order (top → bottom):
+1. **Enemy band** — name, compact enemy HP bar.
+2. **SOUL box** — centered; heart moves here during enemy turn.
+3. **Menu** — slim bar, evenly spaced options.
+4. **Message** — bottom-most text area.
+
+Layout is computed by `BattleHUDLayout` against camera viewport rect so
+letterboxing/pillarboxing from `PixelScale` is respected at any resolution.
+
+Next patch replaces OnGUI with TextMeshPro UI and adds Yarn Spinner.
